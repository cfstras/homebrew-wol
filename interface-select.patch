--- .tmp/wol-0.7.1/include/net.h	2004-02-05 19:20:07
+++ upstream/wol-0.7.1/include/net.h	2026-02-27 12:10:16
@@ -28,7 +28,7 @@
 #include <sys/types.h>
 
 
-int udp_open (void);
+int udp_open (const char *interface_name);
 
 int tcp_open (const char *ip_str, unsigned int port);
 
--- .tmp/wol-0.7.1/src/net.c	2004-04-20 21:51:18
+++ upstream/wol-0.7.1/src/net.c	2026-02-27 12:10:16
@@ -35,6 +35,8 @@
 #include <netdb.h>
 #include <sys/types.h>
 #include <sys/socket.h>
+#include <ifaddrs.h>
+#include <net/if.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
 
@@ -60,7 +62,115 @@
 }
 
 
+static int
+net_ifaddr4 (const char *ifname, struct in_addr *addr)
+{
+  struct ifaddrs *ifaddr;
+  struct ifaddrs *ifa;
 
+  if (ifname == NULL || addr == NULL)
+    {
+      errno = EINVAL;
+      return -1;
+    }
+
+  if (getifaddrs (&ifaddr) != 0)
+    {
+      return -1;
+    }
+
+  for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next)
+    {
+      if (ifa->ifa_addr == NULL)
+        continue;
+
+      if (ifa->ifa_addr->sa_family != AF_INET)
+        continue;
+
+      if (strcmp (ifa->ifa_name, ifname) != 0)
+        continue;
+
+      *addr = ((struct sockaddr_in *) ifa->ifa_addr)->sin_addr;
+      freeifaddrs (ifaddr);
+      return 0;
+    }
+
+  freeifaddrs (ifaddr);
+  errno = ENOENT;
+  return -1;
+}
+
+
+static int
+net_configure_udp_interface (int sockfd, const char *interface_name)
+{
+  int configured = 0;
+
+  if (interface_name == NULL)
+    {
+      return 0;
+    }
+
+  /* If the argument is an IPv4 address, bind to it directly. */
+  {
+    struct in_addr addr;
+    if (inet_aton (interface_name, &addr) != 0)
+      {
+        struct sockaddr_in local;
+        memset (&local, 0, sizeof (local));
+        local.sin_family = AF_INET;
+        local.sin_addr = addr;
+        local.sin_port = htons (0);
+        if (bind (sockfd, (const struct sockaddr *) &local, sizeof (local)) == 0)
+          {
+            return 0;
+          }
+        return -1;
+      }
+  }
+
+  /* Prefer an OS-level "bind to interface" when available. */
+#ifdef IP_BOUND_IF
+  {
+    unsigned int idx = if_nametoindex (interface_name);
+    if (idx != 0)
+      {
+        if (setsockopt (sockfd, IPPROTO_IP, IP_BOUND_IF, &idx, sizeof (idx)) == 0)
+          {
+            configured = 1;
+          }
+      }
+  }
+#endif
+
+  /* Fallback: bind the socket's source address to the interface's IPv4. */
+  {
+    struct in_addr addr;
+    if (net_ifaddr4 (interface_name, &addr) == 0)
+      {
+        struct sockaddr_in local;
+        memset (&local, 0, sizeof (local));
+        local.sin_family = AF_INET;
+        local.sin_addr = addr;
+        local.sin_port = htons (0);
+        if (bind (sockfd, (const struct sockaddr *) &local, sizeof (local)) == 0)
+          {
+            configured = 1;
+          }
+      }
+  }
+
+  if (!configured)
+    {
+      errno = EINVAL;
+      return -1;
+    }
+
+  return 0;
+}
+
+
+
 int
 net_close (int socket)
 {
@@ -76,7 +186,7 @@
 
 
 int
-udp_open (void)
+udp_open (const char *interface_name)
 {
   int optval;
   int sockfd;
@@ -97,6 +207,13 @@
       return -1;
     }
 
+  if (net_configure_udp_interface (sockfd, interface_name) != 0)
+    {
+      error (0, errno, _("Cannot use interface '%s'"), interface_name);
+      close (sockfd);
+      return -1;
+    }
+
   return sockfd;
 }
 
--- .tmp/wol-0.7.1/src/wol.c	2004-04-18 13:42:11
+++ upstream/wol-0.7.1/src/wol.c	2026-02-27 12:10:16
@@ -56,6 +56,9 @@
 /* IP Address or hostname magic packet is addressed to */
 static char *host_str = DEFAULT_IPADDR;
 
+/* outgoing interface name (or local IPv4 address) */
+static char *interface_str = NULL;
+
 /* filename with mac addresses */
 static char *pathname = NULL;
 
@@ -103,6 +106,7 @@
 -w, --wait=NUM      wait NUM millisecs after sending\n\
 -h, --host=HOST     broadcast to this IP address or hostname\n\
 -i, --ipaddr=HOST   same as --host\n\
+-I, --interface=IF  send packets via interface IF\n\
 -p, --port=NUM      broadcast to this UDP port\n\
 -f, --file=FILE     read addresses from file FILE (\"-\" reads from stdin)\n\
     --passwd[=PASS] send SecureON password PASS (if no PASS is given, you\n\
@@ -144,7 +148,7 @@
   int c;
   int option_index;
   int password_set = 0;
-  char *options = "Vvw:h:i:p:f:s:-";
+  char *options = "Vvw:h:i:I:p:f:s:-";
   static struct option long_options[] = 
     {
       { "help", no_argument, NULL, 'H' },
@@ -153,6 +157,7 @@
       { "wait", required_argument, NULL, 'w' },
       { "host", required_argument, NULL, 'h' },
       { "ipaddr", required_argument, NULL, 'i' },
+      { "interface", required_argument, NULL, 'I' },
       { "port", required_argument, NULL, 'p' },
       { "file", required_argument, NULL, 'f' },
       { "passwd", optional_argument, NULL, 'P' },
@@ -209,7 +214,11 @@
 	  host_str = optarg;
 	  break;
 
+  case 'I':
+    interface_str = optarg;
+    break;
 
+
 	case 'p':
 	  if ((sscanf (optarg, "%5u", &port) != 1) ||
 	      port > 65535 || port == 0)
@@ -358,7 +367,7 @@
 
   if (!proxy_mode)
     {
-      sockfd = udp_open ();
+      sockfd = udp_open (interface_str);
     }
   else
     {
